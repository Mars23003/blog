<h2 id=介紹>介紹</h2>
<p>依賴注入（Dependency Injection），落實了在類別的相依性之間達成控制反轉(IoC)的技術，
用於減少程式碼的耦合度，增強模組間的獨立性及可測試性。
.NET Core 推出以來，已內建DI功能，較早期如.Net Framework等 也可以透過第三方DI套件來使用。</p>
<h2 id=什麼是dependency-injection>什麼是Dependency Injection</h2>
<p>我們都知道物件導向程式設計在建立一個物件時會透過<font color=#c7254e style="background: #f9f2f4"><strong>new Class名稱()</strong></font></p>
<p>假設在開發的時候用new的方式建立物件,會有什麼副作用嗎？</p>
<p>以下是一個簡單的範例</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=k>public</span> <span class=k>class</span> <span class=nc>TaxCalculator</span>
<span class=p>{</span>
    <span class=k>public</span> <span class=kt>decimal</span> <span class=n>CalculateTax</span><span class=p>(</span><span class=kt>decimal</span> <span class=n>amount</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=k>return</span> <span class=n>amount</span> <span class=p>*</span> <span class=m>0.08</span><span class=n>M</span><span class=p>;</span>  <span class=c1>// 假設稅率是8%
</span><span class=c1></span>    <span class=p>}</span>
<span class=p>}</span>

<span class=k>public</span> <span class=k>class</span> <span class=nc>ShoppingCart</span>
<span class=p>{</span>
    <span class=k>private</span> <span class=n>List</span><span class=p>&lt;</span><span class=kt>decimal</span><span class=p>&gt;</span> <span class=m>_</span><span class=n>prices</span><span class=p>;</span>
    <span class=k>private</span> <span class=n>TaxCalculator</span> <span class=m>_</span><span class=n>taxCalculator</span><span class=p>;</span>

    <span class=k>public</span> <span class=n>ShoppingCart</span><span class=p>()</span>
    <span class=p>{</span>
        <span class=m>_</span><span class=n>prices</span> <span class=p>=</span> <span class=k>new</span> <span class=n>List</span><span class=p>&lt;</span><span class=kt>decimal</span><span class=p>&gt;();</span>
        <span class=m>_</span><span class=n>taxCalculator</span> <span class=p>=</span> <span class=k>new</span> <span class=n>TaxCalculator</span><span class=p>();</span>  <span class=c1>// 直接透過new()創建
</span><span class=c1></span>    <span class=p>}</span>

    <span class=k>public</span> <span class=k>void</span> <span class=n>AddPrice</span><span class=p>(</span><span class=kt>decimal</span> <span class=n>price</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=m>_</span><span class=n>prices</span><span class=p>.</span><span class=n>Add</span><span class=p>(</span><span class=n>price</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=k>public</span> <span class=kt>decimal</span> <span class=n>CalculateTotal</span><span class=p>()</span>
    <span class=p>{</span>
        <span class=kt>decimal</span> <span class=n>subtotal</span> <span class=p>=</span> <span class=m>_</span><span class=n>prices</span><span class=p>.</span><span class=n>Sum</span><span class=p>();</span>
        <span class=k>return</span> <span class=n>subtotal</span> <span class=p>+</span> <span class=m>_</span><span class=n>taxCalculator</span><span class=p>.</span><span class=n>CalculateTax</span><span class=p>(</span><span class=n>subtotal</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>可能的問題如下</p>
<ol>
<li><font color=#c7254e style="background: #f9f2f4"><strong>耦合性高</strong></font>：ShoppingCart 依賴於具體的 TaxCalculator，這使得它難以適應 TaxCalculator的變化。</li>
<li><font color=#c7254e style="background: #f9f2f4"><strong>難以測試</strong></font>：由於 TaxCalculator的new出來的實例被放到 ShoppingCart 中，這使得在單元測試 ShoppingCart 時，難以對 TaxCalculator 進行模擬。</li>
<li><font color=#c7254e style="background: #f9f2f4"><strong>低靈活性</strong></font>：如果未來需要更換不同的稅率或配置，需要修改 ShoppingCart 的內部實現。</li>
</ol>
<p>那我們能怎麼做呢？
這時候DI就派上用場啦～
以下是修改後的範例</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=k>public</span> <span class=k>interface</span> <span class=n>ITaxCalculator</span>
<span class=p>{</span>
    <span class=kt>decimal</span> <span class=n>CalculateTax</span><span class=p>(</span><span class=kt>decimal</span> <span class=n>amount</span><span class=p>);</span>
<span class=p>}</span>

<span class=k>public</span> <span class=k>class</span> <span class=nc>TaxCalculator</span> <span class=p>:</span> <span class=n>ITaxCalculator</span>
<span class=p>{</span>
    <span class=k>public</span> <span class=kt>decimal</span> <span class=n>CalculateTax</span><span class=p>(</span><span class=kt>decimal</span> <span class=n>amount</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=k>return</span> <span class=n>amount</span> <span class=p>*</span> <span class=m>0.08</span><span class=n>M</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=k>public</span> <span class=k>class</span> <span class=nc>ShoppingCart</span>
<span class=p>{</span>
    <span class=k>private</span> <span class=n>List</span><span class=p>&lt;</span><span class=kt>decimal</span><span class=p>&gt;</span> <span class=m>_</span><span class=n>prices</span><span class=p>;</span>
    <span class=k>private</span> <span class=n>ITaxCalculator</span> <span class=m>_</span><span class=n>taxCalculator</span><span class=p>;</span>

    <span class=c1>// 通過建構子注入依賴
</span><span class=c1></span>    <span class=k>public</span> <span class=n>ShoppingCart</span><span class=p>(</span><span class=n>ITaxCalculator</span> <span class=n>taxCalculator</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=m>_</span><span class=n>prices</span> <span class=p>=</span> <span class=k>new</span> <span class=n>List</span><span class=p>&lt;</span><span class=kt>decimal</span><span class=p>&gt;();</span>
        <span class=m>_</span><span class=n>taxCalculator</span> <span class=p>=</span> <span class=n>taxCalculator</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>public</span> <span class=k>void</span> <span class=n>AddPrice</span><span class=p>(</span><span class=kt>decimal</span> <span class=n>price</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=m>_</span><span class=n>prices</span><span class=p>.</span><span class=n>Add</span><span class=p>(</span><span class=n>price</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=k>public</span> <span class=kt>decimal</span> <span class=n>CalculateTotal</span><span class=p>()</span>
    <span class=p>{</span>
        <span class=kt>decimal</span> <span class=n>subtotal</span> <span class=p>=</span> <span class=m>_</span><span class=n>prices</span><span class=p>.</span><span class=n>Sum</span><span class=p>();</span>
        <span class=k>return</span> <span class=n>subtotal</span> <span class=p>+</span> <span class=m>_</span><span class=n>taxCalculator</span><span class=p>.</span><span class=n>CalculateTax</span><span class=p>(</span><span class=n>subtotal</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>以上透過建構子注入所需介面的方式來使用可以解決高耦合的相關問題
ShoppingCart 類不再自行創建 TaxCalculator 的實例。相反，它通過構造函數接收一個 ITaxCalculator 介面的實現，這種方式讓我們可以靈活地替換不同的稅率計算邏輯。
此外，這也使得在進行單元測試時，我們能夠輕鬆地注入一個假的稅率計算器。這樣的依賴注入方法大幅提升了程式碼的可測試性和可維護性。</p>
<h2 id=net內建的di怎麼用>.Net內建的DI怎麼用？</h2>
<h3 id=設定服務>設定服務</h3>
<p>在 ConfigureServices 方法中註冊所有的依賴：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=k>public</span> <span class=k>void</span> <span class=n>ConfigureServices</span><span class=p>(</span><span class=n>IServiceCollection</span> <span class=n>services</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>services</span><span class=p>.</span><span class=n>AddScoped</span><span class=p>&lt;</span><span class=n>ITaxCalculator</span><span class=p>,</span> <span class=n>TaxCalculator</span><span class=p>&gt;();</span>
    <span class=c1>// services.AddSingleton&lt;ILoggerManager, LoggerManager&gt;();
</span><span class=c1></span><span class=p>}</span>
</code></pre></div><p>上述設置很簡單吧 你有發現Scoped跟Singleton嗎？
其實DI註冊也是有其生命週期的！
讓我們繼續看下去~</p>
<h3 id=di的生命週期>DI的生命週期</h3>
<p><font color=#c7254e style="background: #f9f2f4"><strong>Singleton</strong></font>：每個Process(DI容器)僅一個實例</p>
<p><font color=#c7254e style="background: #f9f2f4"><strong>Scoped</strong></font>：每個HttpRequest會請求一個實例</p>
<p><font color=#c7254e style="background: #f9f2f4"><strong>Transient</strong></font>：每次注入時都會建立新的實例</p>
<h2 id=結語>結語</h2>
<p>理解和利用 .NET DI 容器不僅可以提升你的開發效率，還能幫助你構建更加健壯和可維護的應用。隨著對依賴注入深入了解，你將能夠更好地設計和實施複雜的業務應用。</p>