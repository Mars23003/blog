<p>Bridge Pattern 是一種結構型設計模式，可以用來將抽象和實現部分分離，讓它們可以獨立地變化。</p>
<h2 id=bridge-pattern的四個要素>Bridge Pattern的四個要素：</h2>
<ol>
<li><strong>模式名稱</strong>：</li>
</ol>
<blockquote>
<p>Bridge Pattern，是一種結構型設計模式。</p>
</blockquote>
<ol start=2>
<li><strong>問題</strong>：</li>
</ol>
<blockquote>
<p>當系統需要支援多種平台或者多種應用程式時，程式碼會變得複雜且難以維護。如果要添加新的平台或者應用程式，就需要修改大量的程式碼。同時，這也會造成類之間的緊密耦合，使得程式碼難以測試、重用和擴展。</p>
</blockquote>
<ol start=3>
<li><strong>解決方案</strong>：</li>
</ol>
<blockquote>
<p>Bridge Pattern 的解決方案是將系統中的抽象部分和實現部分分離，讓它們可以獨立地變化。這樣就可以讓系統更容易擴展和修改，同時也能夠降低類之間的耦合程度。</p>
</blockquote>
<ol start=4>
<li><strong>結果</strong>：</li>
</ol>
<blockquote>
<p>Bridge Pattern 的結果是將系統中的抽象和實現部分分離，降低了它們之間的耦合度，使系統更容易擴展和修改。同時，Bridge Pattern 也提高了程式碼的可讀性和可維護性，讓程式碼更易於測試和重用。</p>
</blockquote>
<h2 id=成員與功用>成員與功用</h2>
<style type=text/css>.tg{border-collapse:collapse;border-color:#bbb;border-spacing:0}.tg td{background-color:#e0ffeb;border-color:#bbb;border-style:solid;border-width:0;color:#594f4f;font-family:Arial,sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal}.tg th{background-color:#9de0ad;border-color:#bbb;border-style:solid;border-width:0;color:#493f3f;font-family:Arial,sans-serif;font-size:14px;font-weight:400;overflow:hidden;padding:10px 5px;word-break:normal}.tg .tg-acii{background-color:#fff;border-color:inherit;color:#333;text-align:left;vertical-align:top}.tg .tg-1jc0{background-color:rgba(46,187,170,.5);color:#333;text-align:left;vertical-align:middle}.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}.tg .tg-0lax{text-align:left;vertical-align:top}</style>
<table class=tg>
<thead>
<tr>
<th class=tg-0pky>成員</th>
<th class=tg-0pky>功用</th>
</tr>
</thead>
<tbody>
<tr>
<td class=tg-0pky><span style=font-weight:700;font-style:normal>Abstraction</span>（抽象部分）</td>
<td class=tg-0pky><span style=font-weight:400;font-style:normal>定義抽象部分，並維護一個指向 Implementor（實現部分）對象的引用。它的主要職責是定義出高層次的抽象概念，並依賴 Implementor 來實現。</span></td>
</tr>
<tr>
<td class=tg-0pky><span style=font-weight:700;font-style:normal>RefinedAbstraction</span>（具體抽象部分）</td>
<td class=tg-0pky><span style=font-weight:400;font-style:normal>擴展 Abstraction 的介面，以提供更具體的操作方法。通常會保存一個對 ConcreteImplementor（具體實現部分）的引用。</span></td>
</tr>
<tr>
<td class=tg-0pky><span style=font-weight:700;font-style:normal>Implementor</span>（實現部分）</td>
<td class=tg-0pky><span style=font-weight:400;font-style:normal>定義實現部分的介面，為 Abstraction 提供基本操作，並且可以被 ConcreteImplementor 繼承或實現。</span></td>
</tr>
<tr>
<td class=tg-0pky><span style=font-weight:700;font-style:normal>ConcreteImplementor</span>（具體實現部分）</td>
<td class=tg-0pky><span style=font-weight:400;font-style:normal>實現 Implementor 介面，提供具體的操作方法。</span></td>
</tr>
</tbody>
</table>
<p>以下是 Bridge Pattern 的 C# 實現方式：</p>
<h2 id=ｃ範例>Ｃ#範例</h2>
<h3 id=基本範例>基本範例</h3>
<ol>
<li>定義 Abstraction 抽象類別或介面，定義系統的高層結構和抽象介面：</li>
</ol>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=k>public</span> <span class=k>abstract</span> <span class=k>class</span> <span class=nc>Abstraction</span>
<span class=p>{</span>
    <span class=k>protected</span> <span class=n>Implementor</span> <span class=n>implementor</span><span class=p>;</span>

    <span class=k>public</span> <span class=n>Abstraction</span><span class=p>(</span><span class=n>Implementor</span> <span class=n>implementor</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=k>this</span><span class=p>.</span><span class=n>implementor</span> <span class=p>=</span> <span class=n>implementor</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>public</span> <span class=k>abstract</span> <span class=k>void</span> <span class=n>Operation</span><span class=p>();</span>
<span class=p>}</span>
</code></pre></div><ol start=2>
<li>定義 Implementor 抽象類別或介面，提供 Abstraction 所定義的介面的具體實現：</li>
</ol>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=k>public</span> <span class=k>abstract</span> <span class=k>class</span> <span class=nc>Implementor</span>
<span class=p>{</span>
    <span class=k>public</span> <span class=k>abstract</span> <span class=k>void</span> <span class=n>OperationImp</span><span class=p>();</span>
<span class=p>}</span>
</code></pre></div><ol start=3>
<li>定義 RefinedAbstraction 類別，擴展 Abstraction 類別，實現更細化的抽象介面：</li>
</ol>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>public class RefinedAbstraction : Abstraction
{
    public RefinedAbstraction(Implementor implementor) :base(implementor)
    {
    }

    public override void Operation()
    {
        // 處理具體的業務邏輯
        implementor.OperationImp();
        // 處理具體的業務邏輯
    }
}
</code></pre></div><ol start=4>
<li>定義 ConcreteImplementorA 和 ConcreteImplementorB 類別，擴展 Implementor 類別，提供 Abstraction 所定義的介面的具體實現：</li>
</ol>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=k>public</span> <span class=k>class</span> <span class=nc>ConcreteImplementorA</span> <span class=p>:</span> <span class=n>Implementor</span>
<span class=p>{</span>
    <span class=k>public</span> <span class=k>override</span> <span class=k>void</span> <span class=n>OperationImp</span><span class=p>()</span>
    <span class=p>{</span>
        <span class=c1>// 處理具體的實現邏輯
</span><span class=c1></span>    <span class=p>}</span>
<span class=p>}</span>

<span class=k>public</span> <span class=k>class</span> <span class=nc>ConcreteImplementorB</span> <span class=p>:</span> <span class=n>Implementor</span>
<span class=p>{</span>
    <span class=k>public</span> <span class=k>override</span> <span class=k>void</span> <span class=n>OperationImp</span><span class=p>()</span>
    <span class=p>{</span>
        <span class=c1>// 處理具體的實現邏輯
</span><span class=c1></span>    <span class=p>}</span>
<span class=p>}</span>

<span class=m>5.</span> <span class=err>實例化</span> <span class=n>Abstraction</span> <span class=err>和</span> <span class=n>Implementor</span> <span class=err>的對象，並將它們結合起來：</span>
<span class=err>```</span><span class=n>csharp</span>
<span class=n>Implementor</span> <span class=n>implementorA</span> <span class=p>=</span> <span class=k>new</span> <span class=n>ConcreteImplementorA</span><span class=p>();</span>
<span class=n>Implementor</span> <span class=n>implementorB</span> <span class=p>=</span> <span class=k>new</span> <span class=n>ConcreteImplementorB</span><span class=p>();</span>

<span class=n>Abstraction</span> <span class=n>abstractionA</span> <span class=p>=</span> <span class=k>new</span> <span class=n>RefinedAbstraction</span><span class=p>(</span><span class=n>implementorA</span><span class=p>);</span>
<span class=n>Abstraction</span> <span class=n>abstractionB</span> <span class=p>=</span> <span class=k>new</span> <span class=n>RefinedAbstraction</span><span class=p>(</span><span class=n>implementorB</span><span class=p>);</span>

<span class=n>abstractionA</span><span class=p>.</span><span class=n>Operation</span><span class=p>();</span>
<span class=n>abstractionB</span><span class=p>.</span><span class=n>Operation</span><span class=p>();</span>
</code></pre></div><h3 id=實際產品product為抽象部分以顏色color為實現部分的-bridge-pattern-範例>實際產品（Product）為抽象部分，以「顏色」（Color）為實現部分的 Bridge Pattern 範例：</h3>
<ol>
<li>定義 Color 介面，提供操作顏色的方法：</li>
</ol>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=k>public</span> <span class=k>interface</span> <span class=n>Color</span>
<span class=p>{</span>
    <span class=k>void</span> <span class=n>ApplyColor</span><span class=p>();</span>
<span class=p>}</span>
</code></pre></div><ol start=2>
<li>定義具體的 Color 類別，實現 Color 介面：</li>
</ol>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=k>public</span> <span class=k>class</span> <span class=nc>WhiteColor</span> <span class=p>:</span> <span class=n>Color</span>
<span class=p>{</span>
    <span class=k>public</span> <span class=k>void</span> <span class=n>ApplyColor</span><span class=p>()</span>
    <span class=p>{</span>
        <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>&#34;白色&#34;</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=k>public</span> <span class=k>class</span> <span class=nc>BlackColor</span> <span class=p>:</span> <span class=n>Color</span>
<span class=p>{</span>
    <span class=k>public</span> <span class=k>void</span> <span class=n>ApplyColor</span><span class=p>()</span>
    <span class=p>{</span>
        <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>&#34;黑色&#34;</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><ol start=3>
<li>定義 Product 抽象類別，提供操作產品的方法，並包含一個 Color 對象：</li>
</ol>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=k>public</span> <span class=k>abstract</span> <span class=k>class</span> <span class=nc>Product</span>
<span class=p>{</span>
    <span class=k>protected</span> <span class=n>Color</span> <span class=n>color</span><span class=p>;</span>

    <span class=k>public</span> <span class=n>Product</span><span class=p>(</span><span class=n>Color</span> <span class=n>color</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=k>this</span><span class=p>.</span><span class=n>color</span> <span class=p>=</span> <span class=n>color</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>public</span> <span class=k>abstract</span> <span class=k>void</span> <span class=n>Produce</span><span class=p>();</span>
<span class=p>}</span>
</code></pre></div><ol start=4>
<li>定義具體的 Product 類別，擴展 Product 類別，提供產品的具體實現：</li>
</ol>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=k>public</span> <span class=k>class</span> <span class=nc>Shirt</span> <span class=p>:</span> <span class=n>Product</span>
<span class=p>{</span>
    <span class=k>public</span> <span class=n>Shirt</span><span class=p>(</span><span class=n>Color</span> <span class=n>color</span><span class=p>)</span> <span class=p>:</span> <span class=k>base</span><span class=p>(</span><span class=n>color</span><span class=p>)</span>
    <span class=p>{</span>
    <span class=p>}</span>

    <span class=k>public</span> <span class=k>override</span> <span class=k>void</span> <span class=n>Produce</span><span class=p>()</span>
    <span class=p>{</span>
        <span class=n>Console</span><span class=p>.</span><span class=n>Write</span><span class=p>(</span><span class=s>&#34;上衣，&#34;</span><span class=p>);</span>
        <span class=n>color</span><span class=p>.</span><span class=n>ApplyColor</span><span class=p>();</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=k>public</span> <span class=k>class</span> <span class=nc>Pants</span> <span class=p>:</span> <span class=n>Product</span>
<span class=p>{</span>
    <span class=k>public</span> <span class=n>Pants</span><span class=p>(</span><span class=n>Color</span> <span class=n>color</span><span class=p>)</span> <span class=p>:</span> <span class=k>base</span><span class=p>(</span><span class=n>color</span><span class=p>)</span>
    <span class=p>{</span>
    <span class=p>}</span>

    <span class=k>public</span> <span class=k>override</span> <span class=k>void</span> <span class=n>Produce</span><span class=p>()</span>
    <span class=p>{</span>
        <span class=n>Console</span><span class=p>.</span><span class=n>Write</span><span class=p>(</span><span class=s>&#34;褲子，&#34;</span><span class=p>);</span>
        <span class=n>color</span><span class=p>.</span><span class=n>ApplyColor</span><span class=p>();</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><ol start=5>
<li>實例化 Product 和 Color 的對象，並將它們結合起來：</li>
</ol>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=n>Color</span> <span class=n>whiteColor</span> <span class=p>=</span> <span class=k>new</span> <span class=n>WhiteColor</span><span class=p>();</span>
<span class=n>Color</span> <span class=n>blackColor</span> <span class=p>=</span> <span class=k>new</span> <span class=n>BlackColor</span><span class=p>();</span>

<span class=n>Product</span> <span class=n>whiteShirt</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Shirt</span><span class=p>(</span><span class=n>whiteColor</span><span class=p>);</span>
<span class=n>Product</span> <span class=n>blackPants</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Pants</span><span class=p>(</span><span class=n>blackColor</span><span class=p>);</span>

<span class=n>whiteShirt</span><span class=p>.</span><span class=n>Produce</span><span class=p>();</span>  <span class=c1>// 輸出：上衣，白色
</span><span class=c1></span><span class=n>blackPants</span><span class=p>.</span><span class=n>Produce</span><span class=p>();</span>  <span class=c1>// 輸出：褲子，黑色
</span></code></pre></div><p>以上是一個簡單的以「產品」為抽象部分，以「顏色」為實現部分的 Bridge Pattern 範例，你可以根據實際需求進行修改。</p>
<h2 id=結論>結論</h2>
<blockquote>
<p>Bridge Pattern 的主要優點是可以分離抽象部分和實現部分，使得它們可以獨立地變化。這樣可以提高系統的靈活性，並且有助於簡化系統的設計和實現。</p>
</blockquote>
<blockquote>
<p>Bridge Pattern 的主要缺點是需要額外定義一個 Implementor 類別，增加了系統的複雜度。另外，如果 Abstraction 和 Implementor 的數量過多，可能會導致類別層次結構過於複雜。</p>
</blockquote>
<blockquote>
<p>在實際應用中，Bridge Pattern 可以用於分離抽象類和實現類，尤其是在需要在運行時切換不同的實現時。例如，一個圖形繪製程式可以使用 Bridge Pattern 將圖形的形狀和顏色分離，這樣就可以方便地添加新的圖形形狀或者顏色。</p>
</blockquote>
<blockquote>
<p>如果系統需要支持多種不同的平台或者介面，也可以使用 Bridge Pattern 將平台或介面的實現和抽象分離，這樣就可以方便地添加新的平台或者介面。</p>
</blockquote>
<p>總之，Bridge Pattern 是一個非常有用的設計模式，它可以提高系統的靈活性和可擴展性，有助於簡化系統的設計和實現。</p>
<h2>延伸閱讀</h2>
<ul>
<li><a href=/blog/posts/designpattern/compositepattern/>[Design Pattern] 掌握設計模式：Composite Pattern原理與應用</a></li>
<li><a href=/blog/posts/designpattern/adapterpattern/>[Design Pattern] 掌握設計模式：Adapter Pattern原理與應用</a></li>
<li><a href=/blog/posts/designpattern/prototypepattern/>[Design Pattern] 掌握設計模式：Prototype Pattern原理與應用</a></li>
<li><a href=/blog/posts/designpattern/builderpattern/>[Design Pattern] 掌握設計模式：Builder Pattern原理與應用</a></li>
<li><a href=/blog/posts/designpattern/abstractfactorypattern/>[Design Pattern] 掌握設計模式：Abstract Factory Pattern原理與應用</a></li>
</ul>