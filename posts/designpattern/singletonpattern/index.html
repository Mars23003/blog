<h2 id=簡介>簡介</h2>
<h3 id=模式名稱>模式名稱：</h3>
<p>Singleton Pattern</p>
<h3 id=問題>問題：</h3>
<p>在某些情況下，我們需要確保一個類只能創建一個實例，並且該實例在整個應用程序中都是全局可用的。例如，當我們需要一個全局的資料庫連接、設定管理或Log系統時，這些對象只需要一個實例即可，以避免重複創建對象的開銷和維護困難。</p>
<h3 id=解決方案>解決方案：</h3>
<p>Singleton Pattern 通過將一個類的構造函數設置為私有，並提供一個靜態方法來獲取該類的唯一實例，確保了該類只有一個實例存在。在第一次調用該靜態方法時，會創建一個唯一的實例，並在以後的調用中返回相同的實例。</p>
<h3 id=結果>結果：</h3>
<p>Singleton Pattern 可以確保類只有一個實例存在，並且該實例在整個應用程序中都是全局可用的，減少了對象的創建和維護成本。但是，Singleton Pattern 也可能引起一些問題，例如單例類可能會導致代碼的耦合度增加，並使代碼難以測試。</p>
<h2 id=c簡單實作>C#簡單實作</h2>
<p>使用一個 <font color=#c7254e style="background: #f9f2f4"> <strong>private的建構式</strong></font>和一個<font color=#c7254e style="background: #f9f2f4"> <strong>static的readonly實例</strong></font>，以確保只有一個Singleton實例存在。
並提供了一個<font color=#c7254e style="background: #f9f2f4"> <strong>static的Instance 屬性</strong></font>，以便其他程式碼可以訪問 Singleton 實例。
可以使用 <font color=#c7254e style="background: #f9f2f4"> <strong>sealed</strong></font> 關鍵字來防止該類被繼承。</p>
<p>在 C# 中，實現 Singleton Pattern 的方式有多種，下面我們將介紹三種初始化的方式：<font color=#c7254e style="background: #f9f2f4"> <strong>Eager Initialization</strong></font>、<font color=#c7254e style="background: #f9f2f4"> <strong>Lazy Initialization</strong></font>和 <font color=#c7254e style="background: #f9f2f4"> <strong>Thread-Safe Initialization</strong></font>。</p>
<h3 id=eager-initialization>Eager Initialization</h3>
<p>是一種在應用程式啟動時立即建立 Singleton 實例的方式。這種方式簡單易行，且 Singleton 實例會在程式一開始就建立好，並且在整個應用程式運行期間都是存在的。</p>
<p>以下是使用 Eager Initialization 實現 Singleton Pattern 的 C# 程式碼範例：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=k>public</span> <span class=k>sealed</span> <span class=k>class</span> <span class=nc>Singleton</span>
<span class=p>{</span>
    <span class=k>private</span> <span class=k>static</span> <span class=k>readonly</span> <span class=n>Singleton</span> <span class=n>instance</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Singleton</span><span class=p>();</span>

    <span class=k>private</span> <span class=n>Singleton</span><span class=p>()</span> <span class=p>{</span> <span class=p>}</span>

    <span class=k>public</span> <span class=k>static</span> <span class=n>Singleton</span> <span class=n>Instance</span>
    <span class=p>{</span>
        <span class=k>get</span>
        <span class=p>{</span>
            <span class=k>return</span> <span class=n>instance</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>在這個程式碼中，Singleton 類只有一個私有的實例 instance，並通過靜態的 Instance 屬性進行訪問。Singleton 的建構函數是私有的，因此外部無法創建 Singleton 實例，只能通過 Singleton.Instance 屬性獲取唯一的實例。</p>
<h3 id=lazy-initialization>Lazy Initialization</h3>
<p>是一種在第一次調用 Singleton 實例時才建立實例的方式。這種方式可以節省系統資源，但是可能會造成執行緒安全問題，需要特別注意。</p>
<p>以下是使用 Lazy Initialization 實現 Singleton Pattern 的 C# 程式碼範例：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=k>public</span> <span class=k>sealed</span> <span class=k>class</span> <span class=nc>Singleton</span>
<span class=p>{</span>
    <span class=k>private</span> <span class=k>static</span> <span class=k>readonly</span> <span class=n>Lazy</span><span class=p>&lt;</span><span class=n>Singleton</span><span class=p>&gt;</span> <span class=n>lazyInstance</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Lazy</span><span class=p>&lt;</span><span class=n>Singleton</span><span class=p>&gt;(()</span> <span class=p>=&gt;</span> <span class=k>new</span> <span class=n>Singleton</span><span class=p>());</span>

    <span class=k>private</span> <span class=n>Singleton</span><span class=p>()</span> <span class=p>{</span> <span class=p>}</span>

    <span class=k>public</span> <span class=k>static</span> <span class=n>Singleton</span> <span class=n>Instance</span>
    <span class=p>{</span>
        <span class=k>get</span>
        <span class=p>{</span>
            <span class=k>return</span> <span class=n>lazyInstance</span><span class=p>.</span><span class=n>Value</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>在這個程式碼中，Singleton 類只有一個私有的實例 lazyInstance，並通過靜態的 Instance 屬性進行訪問。Singleton 的建構函數是私有的，因此外部無法創建 Singleton 實例，只能通過 Singleton.Instance 屬性獲取唯一的實例。使用 Lazy<singleton> 類型可以實現在第一次調用時才建立 Singleton 實例的效果。</p>
<h3 id=thread-safe-initialization>Thread-Safe Initialization</h3>
<p>是一種在多執行緒環境下安全地創建 Singleton 實例的方式。這種方式可以保證 Singleton 實例在多執行緒環境下的唯一性和一致性，但是可能會降低效能。</p>
<p>以下是使用 Thread-Safe Initialization 實現 Singleton Pattern 的 C# 程式碼範例：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=k>public</span> <span class=k>sealed</span> <span class=k>class</span> <span class=nc>Singleton</span>
<span class=p>{</span>
    <span class=k>private</span> <span class=k>static</span> <span class=n>volatile</span> <span class=n>Singleton</span> <span class=n>instance</span> <span class=p>=</span> <span class=k>null</span><span class=p>;</span>
    <span class=k>private</span> <span class=k>static</span> <span class=k>readonly</span> <span class=kt>object</span> <span class=n>syncRoot</span> <span class=p>=</span> <span class=k>new</span> <span class=kt>object</span><span class=p>();</span>

    <span class=k>private</span> <span class=n>Singleton</span><span class=p>()</span> <span class=p>{</span> <span class=p>}</span>

    <span class=k>public</span> <span class=k>static</span> <span class=n>Singleton</span> <span class=n>Instance</span>
    <span class=p>{</span>
        <span class=k>get</span>
        <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>instance</span> <span class=p>==</span> <span class=k>null</span><span class=p>)</span>
            <span class=p>{</span>
                <span class=k>lock</span> <span class=p>(</span><span class=n>syncRoot</span><span class=p>)</span>
                <span class=p>{</span>
                    <span class=k>if</span> <span class=p>(</span><span class=n>instance</span> <span class=p>==</span> <span class=k>null</span><span class=p>)</span>
                    <span class=p>{</span>
                        <span class=n>instance</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Singleton</span><span class=p>();</span>
                    <span class=p>}</span>
                <span class=p>}</span>
            <span class=p>}</span>
            <span class=k>return</span> <span class=n>instance</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>這段程式碼中，使用了 volatile 關鍵字來保證 instance 變數的可見性。在 Singleton 類中，首先檢查 instance 是否為 null，如果是，就鎖定 syncRoot 物件，然後再次檢查 instance 是否為 null。如果仍然是 null，則創建一個新的 Singleton 實例，並將其賦值給 instance 變數。最後，釋放鎖定並返回 instance 變數的值。
雙重檢查鎖定方式可以減少多線程環境中的 lock 操作，從而提高程式碼的效率。同時也能保證 Singleton 實例只被創建一次，且線程安全。但要注意，這種方式的實現較為複雜，需要確保 instance 變數的可見性，否則可能會導致 Singleton 實例被創建多次的問題。</p>
<p><code>以上是三種常見的實現 Singleton Pattern 的方式，選擇哪一種方式取決於具體的應用場景。需要注意的是，Singleton Pattern 不應該被濫用，否則會導致程式難以測試、可讀性降低等問題。</code></p>
<h2>延伸閱讀</h2>
<ul>
<li><a href=/blog/posts/designpattern/compositepattern/>[Design Pattern] 掌握設計模式：Composite Pattern原理與應用</a></li>
<li><a href=/blog/posts/designpattern/bridgepattern/>[Design Pattern] 掌握設計模式：Bridge Pattern原理與應用</a></li>
<li><a href=/blog/posts/designpattern/adapterpattern/>[Design Pattern] 掌握設計模式：Adapter Pattern原理與應用</a></li>
<li><a href=/blog/posts/designpattern/prototypepattern/>[Design Pattern] 掌握設計模式：Prototype Pattern原理與應用</a></li>
<li><a href=/blog/posts/designpattern/builderpattern/>[Design Pattern] 掌握設計模式：Builder Pattern原理與應用</a></li>
</ul>